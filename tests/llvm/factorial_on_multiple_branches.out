STDOUT:
CFG Debug Dump Before Hoist Pass
BBId(0): % preds = []
  %0 = param[0] [var n]
  %2 = const.i64 1
  %3 = leq %0, %2
  br_cond %3 ? BBId(1) : BBId(2)


BBId(1): % preds = [BBId(0)]
  %4 = const.i64 1
  return %4


BBId(2): % preds = [BBId(0)]
  %6 = function v1 [var factorial]
  %8 = const.i64 1
  %9 = sub %0, %8
  %10 = call %6(%9)
  %11 = mul %0, %10
  return %11



CFG Debug Dump After Hoist Pass
BBId(0): % preds = []
  %0 = param[0] [var n]
  %2 = const.i64 1
  %3 = leq %0, %2
  br_cond %3 ? BBId(1) : BBId(2)


BBId(1): % preds = [BBId(0)]
  return %2


BBId(2): % preds = [BBId(0)]
  %6 = function v1 [var factorial]
  %9 = sub %0, %2
  %10 = call %6(%9)
  %11 = mul %0, %10
  return %11



CFG for function factorial:
BBId(0): % preds = []
  %0 = param[0] [var n]
  %2 = const.i64 1
  %3 = leq %0, %2
  br_cond %3 ? BBId(1) : BBId(2)

BBId(1): % preds = [BBId(0)]
  return %2

BBId(2): % preds = [BBId(0)]
  %6 = function v1 [var factorial]
  %9 = sub %0, %2
  %10 = call %6(%9)
  %11 = mul %0, %10
  return %11


CFG Debug Dump Before Hoist Pass
BBId(0): % preds = []
  br BBId(1)


BBId(1): % preds = [BBId(0), BBId(2)]
  %30 = Φ(0@BB0, %17@BB2) [var i]
  %33 = Φ(2@BB0, %13@BB2) [var result]
  %10 = const.i64 3
  %11 = lt %30, %10
  br_cond %11 ? BBId(2) : BBId(3)


BBId(2): % preds = [BBId(1)]
  %13 = add %33, %30 [var result]
  %16 = const.i64 1
  %17 = add %30, %16
  br BBId(1)


BBId(3): % preds = [BBId(1)]
  %21 = function v1 [var factorial]
  %23 = call %21(%33)
  return %23



CFG Debug Dump After Hoist Pass
BBId(0): % preds = []
  br BBId(1)


BBId(1): % preds = [BBId(0), BBId(2)]
  %30 = Φ(0@BB0, %17@BB2) [var i]
  %33 = Φ(2@BB0, %13@BB2) [var result]
  %10 = const.i64 3
  %11 = lt %30, %10
  br_cond %11 ? BBId(2) : BBId(3)


BBId(2): % preds = [BBId(1)]
  %13 = add %33, %30 [var result]
  %16 = const.i64 1
  %17 = add %30, %16
  br BBId(1)


BBId(3): % preds = [BBId(1)]
  %21 = function v1 [var factorial]
  %23 = call %21(%33)
  return %23



CFG for function main:
BBId(0): % preds = []
  br BBId(1)

BBId(1): % preds = [BBId(0), BBId(2)]
  %30 = Φ(0@BB0, %17@BB2) [var i]
  %33 = Φ(2@BB0, %13@BB2) [var result]
  %10 = const.i64 3
  %11 = lt %30, %10
  br_cond %11 ? BBId(2) : BBId(3)

BBId(2): % preds = [BBId(1)]
  %13 = add %33, %30 [var result]
  %16 = const.i64 1
  %17 = add %30, %16
  br BBId(1)

BBId(3): % preds = [BBId(1)]
  %21 = function v1 [var factorial]
  %23 = call %21(%33)
  return %23


Generated LLVM IR:
; ModuleID = 'module'
source_filename = "module"

define i64 @factorial(i64 %0) {
bb0:
  %cmp = icmp sle i64 %0, 1
  br i1 %cmp, label %bb1, label %bb2

bb1:                                              ; preds = %bb0
  ret i64 1

bb2:                                              ; preds = %bb0
  %sub = sub i64 %0, 1
  %call = call i64 @factorial(i64 %sub)
  %mul = mul i64 %0, %call
  ret i64 %mul
}

define i64 @main() {
bb0:
  br label %bb1

bb1:                                              ; preds = %bb2, %bb0
  %phi = phi i64 [ 0, %bb0 ], [ %add2, %bb2 ]
  %phi1 = phi i64 [ 2, %bb0 ], [ %add, %bb2 ]
  %cmp = icmp slt i64 %phi, 3
  br i1 %cmp, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %add = add i64 %phi1, %phi
  %add2 = add i64 %phi, 1
  br label %bb1

bb3:                                              ; preds = %bb1
  %call = call i64 @factorial(i64 %phi1)
  ret i64 %call
}

Optimized LLVM IR:
; ModuleID = 'module'
source_filename = "module"

; Function Attrs: nofree norecurse nosync nounwind memory(none)
define i64 @factorial(i64 %0) local_unnamed_addr #0 {
bb0:
  %cmp1 = icmp slt i64 %0, 2
  br i1 %cmp1, label %common.ret, label %bb2

common.ret:                                       ; preds = %bb2, %bb0
  %accumulator.tr.lcssa = phi i64 [ 1, %bb0 ], [ %mul, %bb2 ]
  ret i64 %accumulator.tr.lcssa

bb2:                                              ; preds = %bb0, %bb2
  %.tr3 = phi i64 [ %sub, %bb2 ], [ %0, %bb0 ]
  %accumulator.tr2 = phi i64 [ %mul, %bb2 ], [ 1, %bb0 ]
  %sub = add nsw i64 %.tr3, -1
  %mul = mul i64 %.tr3, %accumulator.tr2
  %cmp = icmp samesign ult i64 %.tr3, 3
  br i1 %cmp, label %common.ret, label %bb2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i64 @main() local_unnamed_addr #1 {
factorial.exit:
  ret i64 120
}

attributes #0 = { nofree norecurse nosync nounwind memory(none) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }


STDERR:
