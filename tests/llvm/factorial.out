STDOUT:
CFG for function factorial:
bb0: % preds = []
  %0 = param[0] [var n]
  %2 = const.i64 1
  %3 = leq %0, %2
  br_cond %3 ? bb1 : bb2

bb1: % preds = [bb0]
  return %2

bb2: % preds = [bb0]
  %6 = function v1 [var factorial]
  %9 = sub %0, %2
  %10 = call %6(%9)
  %11 = mul %0, %10
  return %11


Generated LLVM IR:
; ModuleID = 'module'
source_filename = "module"

define i64 @factorial(i64 %0) {
bb0:
  %cmp = icmp sle i64 %0, 1
  br i1 %cmp, label %bb1, label %bb2

bb1:                                              ; preds = %bb0
  ret i64 1

bb2:                                              ; preds = %bb0
  %sub = sub i64 %0, 1
  %call = call i64 @factorial(i64 %sub)
  %mul = mul i64 %0, %call
  ret i64 %mul
}

Optimized LLVM IR:
; ModuleID = 'module'
source_filename = "module"

; Function Attrs: nofree norecurse nosync nounwind memory(none)
define i64 @factorial(i64 %0) local_unnamed_addr #0 {
bb0:
  %cmp1 = icmp slt i64 %0, 2
  br i1 %cmp1, label %common.ret, label %bb2

common.ret:                                       ; preds = %bb2, %bb0
  %accumulator.tr.lcssa = phi i64 [ 1, %bb0 ], [ %mul, %bb2 ]
  ret i64 %accumulator.tr.lcssa

bb2:                                              ; preds = %bb0, %bb2
  %.tr3 = phi i64 [ %sub, %bb2 ], [ %0, %bb0 ]
  %accumulator.tr2 = phi i64 [ %mul, %bb2 ], [ 1, %bb0 ]
  %sub = add nsw i64 %.tr3, -1
  %mul = mul i64 %.tr3, %accumulator.tr2
  %cmp = icmp samesign ult i64 %.tr3, 3
  br i1 %cmp, label %common.ret, label %bb2
}

attributes #0 = { nofree norecurse nosync nounwind memory(none) }


STDERR:
