STDOUT:
CFG for function factorial:
bb0: % preds = []
  %0 = param[0] [var n]
  %2 = const.i64 1
  %3 = leq %0, %2
  br_cond %3 ? bb1 : bb2

bb1: % preds = [bb0]
  return %2

bb2: % preds = [bb0]
  %6 = function v1 [var factorial]
  %9 = sub %0, %2
  %10 = call %6(%9)
  %11 = mul %0, %10
  return %11


CFG for function main:
bb0: % preds = []
  br bb1

bb1: % preds = [bb0, bb2]
  %25 = Φ(0@bb0, %17@bb2) [var i]
  %28 = Φ(2@bb0, %13@bb2) [var result]
  %10 = const.i64 10
  %11 = lt %25, %10
  br_cond %11 ? bb2 : bb3

bb2: % preds = [bb1]
  %13 = add %28, %25 [var result]
  %16 = const.i64 1
  %17 = add %25, %16
  br bb1

bb3: % preds = [bb1]
  %18 = function v1 [var factorial]
  %20 = call %18(%28)
  %21 = const.i64 0
  return %21


Generated LLVM IR:
; ModuleID = 'module'
source_filename = "module"

define i64 @factorial(i64 %0) {
bb0:
  %cmp = icmp sle i64 %0, 1
  br i1 %cmp, label %bb1, label %bb2

bb1:                                              ; preds = %bb0
  ret i64 1

bb2:                                              ; preds = %bb0
  %sub = sub i64 %0, 1
  %call = call i64 @factorial(i64 %sub)
  %mul = mul i64 %0, %call
  ret i64 %mul
}

define i64 @main() {
bb0:
  br label %bb1

bb1:                                              ; preds = %bb2, %bb0
  %phi = phi i64 [ 0, %bb0 ], [ %add2, %bb2 ]
  %phi1 = phi i64 [ 2, %bb0 ], [ %add, %bb2 ]
  %cmp = icmp slt i64 %phi, 10
  br i1 %cmp, label %bb2, label %bb3

bb2:                                              ; preds = %bb1
  %add = add i64 %phi1, %phi
  %add2 = add i64 %phi, 1
  br label %bb1

bb3:                                              ; preds = %bb1
  %call = call i64 @factorial(i64 %phi1)
  ret i64 0
}

Optimized LLVM IR:
; ModuleID = 'module'
source_filename = "module"

; Function Attrs: nofree norecurse nosync nounwind memory(none)
define i64 @factorial(i64 %0) local_unnamed_addr #0 {
bb0:
  %cmp1 = icmp slt i64 %0, 2
  br i1 %cmp1, label %common.ret, label %bb2

common.ret:                                       ; preds = %bb2, %bb0
  %accumulator.tr.lcssa = phi i64 [ 1, %bb0 ], [ %mul, %bb2 ]
  ret i64 %accumulator.tr.lcssa

bb2:                                              ; preds = %bb0, %bb2
  %.tr3 = phi i64 [ %sub, %bb2 ], [ %0, %bb0 ]
  %accumulator.tr2 = phi i64 [ %mul, %bb2 ], [ 1, %bb0 ]
  %sub = add nsw i64 %.tr3, -1
  %mul = mul i64 %.tr3, %accumulator.tr2
  %cmp = icmp samesign ult i64 %.tr3, 3
  br i1 %cmp, label %common.ret, label %bb2
}

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define noundef i64 @main() local_unnamed_addr #1 {
factorial.exit:
  ret i64 0
}

attributes #0 = { nofree norecurse nosync nounwind memory(none) }
attributes #1 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }


STDERR:
