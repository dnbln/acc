STDOUT:
CFG Debug Dump before HoistPass
BBId(0): % preds = []
  %0 = param[0] [var a]
  %1 = param[1] [var b]
  %4 = add %0, %1
  %7 = mul %0, %1
  %10 = lt %0, %1
  br_cond %10 ? BBId(1) : BBId(2)


BBId(1): % preds = [BBId(0)]
  %13 = sub %0, %1
  br BBId(3)


BBId(2): % preds = [BBId(0)]
  %17 = sub %0, %1
  br BBId(3)


BBId(3): % preds = [BBId(1), BBId(2)]
  %30 = Φ(%13@BB1, %4@BB2) [var x]
  %31 = Φ(%7@BB1, %17@BB2) [var y]
  %21 = mul %30, %31
  return %21



CFG Graphviz Dump before HoistPass
digraph CFG {
  node [shape=box, fontname="Courier New", fontsize=10];
  edge [fontname="Courier New", fontsize=9];
  BB0 [label="BB0:\n  %0 = param[0] [var a]\n  %1 = param[1] [var b]\n  %4 = add %0, %1\n  %7 = mul %0, %1\n  %10 = lt %0, %1\n  br_cond %10 ? BB1 : BB2\n"];
  BB0 -> BB1 [color=green];
  BB0 -> BB2 [color=red];
  BB1 [label="BB1:\n  %13 = sub %0, %1\n  br BB3\n"];
  BB1 -> BB3;
  BB2 [label="BB2:\n  %17 = sub %0, %1\n  br BB3\n"];
  BB2 -> BB3;
  BB3 [label="BB3:\n  %30 = Φ(%13@BB1, %4@BB2) [var \"x\"]\n  %31 = Φ(%7@BB1, %17@BB2) [var \"y\"]\n  %21 = mul %30, %31\n  return %21\n"];
}

CFG Debug Dump after HoistPass
BBId(0): % preds = []
  %0 = param[0] [var a]
  %1 = param[1] [var b]
  %4 = add %0, %1
  %7 = mul %0, %1
  %10 = lt %0, %1
  %34 = sub %0, %1
  br_cond %10 ? BBId(1) : BBId(2)


BBId(1): % preds = [BBId(0)]
  br BBId(3)


BBId(2): % preds = [BBId(0)]
  br BBId(3)


BBId(3): % preds = [BBId(1), BBId(2)]
  %30 = Φ(%34@BB1, %4@BB2) [var x]
  %31 = Φ(%7@BB1, %34@BB2) [var y]
  %21 = mul %30, %31
  return %21



CFG Graphviz Dump after HoistPass
digraph CFG {
  node [shape=box, fontname="Courier New", fontsize=10];
  edge [fontname="Courier New", fontsize=9];
  BB0 [label="BB0:\n  %0 = param[0] [var a]\n  %1 = param[1] [var b]\n  %4 = add %0, %1\n  %7 = mul %0, %1\n  %10 = lt %0, %1\n  %34 = sub %0, %1\n  br_cond %10 ? BB1 : BB2\n"];
  BB0 -> BB1 [color=green];
  BB0 -> BB2 [color=red];
  BB1 [label="BB1:\n  br BB3\n"];
  BB1 -> BB3;
  BB2 [label="BB2:\n  br BB3\n"];
  BB2 -> BB3;
  BB3 [label="BB3:\n  %30 = Φ(%34@BB1, %4@BB2) [var \"x\"]\n  %31 = Φ(%7@BB1, %34@BB2) [var \"y\"]\n  %21 = mul %30, %31\n  return %21\n"];
}

CFG for function main:
BBId(0): % preds = []
  %0 = param[0] [var a]
  %1 = param[1] [var b]
  %4 = add %0, %1
  %7 = mul %0, %1
  %10 = lt %0, %1
  %34 = sub %0, %1
  %36 = select %10, %34, %4 [var x]
  %37 = select %10, %7, %34 [var y]
  %21 = mul %36, %37
  return %21


Generated LLVM IR:
; ModuleID = 'module'
source_filename = "module"

define i64 @main(i64 %0, i64 %1) {
bb0:
  %add = add i64 %0, %1
  %mul = mul i64 %0, %1
  %cmp = icmp slt i64 %0, %1
  %sub = sub i64 %0, %1
  %select = select i1 %cmp, i64 %sub, i64 %add
  %select1 = select i1 %cmp, i64 %mul, i64 %sub
  %mul2 = mul i64 %select, %select1
  ret i64 %mul2
}

Optimized LLVM IR:
; ModuleID = 'module'
source_filename = "module"

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i64 @main(i64 %0, i64 %1) local_unnamed_addr #0 {
bb0:
  %add = add i64 %1, %0
  %mul = mul i64 %1, %0
  %cmp = icmp slt i64 %0, %1
  %sub = sub i64 %0, %1
  %select = select i1 %cmp, i64 %sub, i64 %add
  %select1 = select i1 %cmp, i64 %mul, i64 %sub
  %mul2 = mul i64 %select, %select1
  ret i64 %mul2
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }


STDERR:
