STDOUT:
CFG for function f:
bb0: % preds = []
  %0 = param[0] [var a]
  %1 = param[1] [var b]
  %4 = gt %0, %1
  br_cond %4 ? bb1 : bb4

bb1: % preds = [bb0]
  %7 = neq %0, %1
  br_cond %7 ? bb3 : bb2

bb2: % preds = [bb1]
  %9 = const.i64 0
  %10 = gt %1, %9
  br bb3

bb3: % preds = [bb1, bb2]
  %11 = Φ(true@bb1, %10@bb2)
  br bb4

bb4: % preds = [bb0, bb3]
  %12 = Φ(false@bb0, %11@bb3)
  return %12


Generated LLVM IR:
; ModuleID = 'module'
source_filename = "module"

define i1 @f(i64 %0, i64 %1) {
bb0:
  %cmp = icmp sgt i64 %0, %1
  br i1 %cmp, label %bb1, label %bb4

bb1:                                              ; preds = %bb0
  %cmp1 = icmp ne i64 %0, %1
  br i1 %cmp1, label %bb3, label %bb2

bb2:                                              ; preds = %bb1
  %cmp2 = icmp sgt i64 %1, 0
  br label %bb3

bb3:                                              ; preds = %bb2, %bb1
  %phi = phi i1 [ true, %bb1 ], [ %cmp2, %bb2 ]
  br label %bb4

bb4:                                              ; preds = %bb3, %bb0
  %phi3 = phi i1 [ false, %bb0 ], [ %phi, %bb3 ]
  ret i1 %phi3
}

Optimized LLVM IR:
; ModuleID = 'module'
source_filename = "module"

; Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
define i1 @f(i64 %0, i64 %1) local_unnamed_addr #0 {
bb0:
  %cmp = icmp sgt i64 %0, %1
  ret i1 %cmp
}

attributes #0 = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }


STDERR:
